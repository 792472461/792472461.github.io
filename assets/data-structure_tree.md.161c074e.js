import{_ as l,o as i,c as e,a as d}from"./app.57c057be.js";const a=JSON.parse('{"title":"树结构","description":"","frontmatter":{},"headers":[{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":2,"title":"二叉搜索树","slug":"二叉搜索树","link":"#二叉搜索树","children":[]},{"level":2,"title":"AVL树","slug":"avl树","link":"#avl树","children":[]},{"level":2,"title":"红黑树","slug":"红黑树","link":"#红黑树","children":[]},{"level":2,"title":"线段树","slug":"线段树","link":"#线段树","children":[]},{"level":2,"title":"并查集","slug":"并查集","link":"#并查集","children":[]},{"level":2,"title":"字典树","slug":"字典树","link":"#字典树","children":[]}],"relativePath":"data-structure/tree.md"}'),c={name:"data-structure/tree.md"},o=[d('<h1 id="树结构" tabindex="-1">树结构 <a class="header-anchor" href="#树结构" aria-hidden="true">#</a></h1><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-hidden="true">#</a></h2><p>树</p><ul><li>节点、根节点、父节点、子节点、兄弟节点、子树、左子树、右子树</li><li>一棵树一个节点都没有，被称为空树</li><li>一棵树可以只有1个节点，也就是根节点</li><li>节点的度：子树的个数</li><li>树的度：所有节点中最大值</li><li>叶子节点：度为0的节点</li><li>层数：根节点是第1层，根节点的子节点是第2层，以此类推</li><li>深度：从根节点到当前节点的唯一路径上节点的总数</li><li>高度：从当前节点到最远叶子节点的路径上的节点总数</li><li>树的深度：所有节点深度中的最大值</li><li>树的高度：所有节点高度中的最大值</li><li>一般树的高度和树的深度是相等的</li></ul><p>二叉树</p><ul><li>每个节点的度最大为2(最多拥有2个子树)</li><li>左子树和右子树是有顺序的，左子树小于右子树</li><li>即使某节点只有一棵子树，也要区分左右子树</li><li>二叉树是有序树</li><li>非空二叉树的第i层，最多又<code>2的(i - 1)</code>次方个节点</li><li>高度为h的二叉树上最多有<code>2的(h)次方 - 1</code>个节点</li><li>对于任何一棵非空二叉树，如果叶子节点个数为<code>n0</code>，度为<code>2</code>的节点个数为<code>n2</code>，则<code>n0 = n2 + 1</code></li></ul><p>真二叉树</p><ul><li>所有的节点的度要么为0，要么为2</li></ul><p>满二叉树</p><ul><li>所有的节点要么为0，要么为1</li><li>所有的叶子节点都在最后一层</li><li>在同样高度的二叉树中，满二叉树的叶子节点是最多的、总结点数量也是最多的</li><li>满二叉树一定是真二叉树，真二叉树不一定是满二叉树</li><li>假设满二叉树的高度为h，那么 <ol><li>第<code>i</code>层节点的数量：<code>2的(i - 1)次方</code></li><li>叶子节点数量：<code>2的(h - 1)次方</code></li><li>总节点数量 n = log2(n + 1)</li></ol></li></ul><p>完全二叉树</p><ul><li>叶子节点只会出现在最后2层</li><li>最后1层的叶子节点只会靠左对齐</li><li>从根节点到倒数第2层是满二叉树</li><li>满二叉树一定是一个完全二叉树，完全二叉树不一定是满二叉树</li><li>度为1的节点只有左子树</li><li>度为1的节点要么是1个要么是0个</li><li>同样节点数量的二叉树，完全二叉树的高度最小</li><li>假设完全二叉树的高度是h，那么 <ol><li>至少有<code>2的(h - 1)次方</code>个节点</li><li>最多有<code>2的(h)次方 - 1</code>个节点（也就是满二叉树）</li><li>总结点数量为n</li></ol></li><li>一颗有n个节点的完全二叉树，从上到下、从左到右从0开始编号，对任意一个第i个节点 <ol><li>如果<code>i=0</code>，它是<code>根</code>节点</li><li>如果<code>i&gt;0</code>，它的<code>父</code>节点编号是<code>Math.floor(i - 1) / 2</code></li><li>如果<code>2i + 1 ≤ n - 1</code>，它的<code>左子节点</code>编号为<code>2i + 1</code></li><li>如果<code>2i + 1 ＞ n - 1</code>，它的无<code>左子节点</code></li><li>如果<code>2i + 2 ≤ n - 1</code>，它的<code>右子节点</code>编号为<code>2i + 2</code></li></ol></li></ul><h2 id="二叉搜索树" tabindex="-1">二叉搜索树 <a class="header-anchor" href="#二叉搜索树" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">概念</p><ol><li>二叉搜索树是二叉树的一种英文简称BST</li><li>任意一个节点的值都大于其左子树所有节点的值</li><li>任意一个节点都值都小于其右子树所有节点的值</li><li>它的左右子树也是一个二叉搜索树</li><li>二叉树存储的数据必须具备可比较性</li><li>不允许为null</li></ol></div><h2 id="avl树" tabindex="-1">AVL树 <a class="header-anchor" href="#avl树" aria-hidden="true">#</a></h2><h2 id="红黑树" tabindex="-1">红黑树 <a class="header-anchor" href="#红黑树" aria-hidden="true">#</a></h2><h2 id="线段树" tabindex="-1">线段树 <a class="header-anchor" href="#线段树" aria-hidden="true">#</a></h2><h2 id="并查集" tabindex="-1">并查集 <a class="header-anchor" href="#并查集" aria-hidden="true">#</a></h2><h2 id="字典树" tabindex="-1">字典树 <a class="header-anchor" href="#字典树" aria-hidden="true">#</a></h2>',19)];const r=l(c,[["render",function(l,d,a,c,r,h){return i(),e("div",null,o)}]]);export{a as __pageData,r as default};
